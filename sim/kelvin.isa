// This file define the kelvin isa for mpact-sim. For more info on mpact-sim isa
// format, check: go/mpact-sim-codelabs-riscv-instruction-decoder

// First disasm field is 18 char wide and left justified.
disasm widths = {-18};

int global_latency = 0;

isa Kelvin {
  namespace kelvin::sim::isa32;
  slots { kelvin; }
}

// Basic integer ALU instructions, part of the RiscV 32i subset.
slot riscv32i {
  includes {
    #include "riscv/riscv_i_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  resources TwoOp = { next_pc, rs1 : rd[..rd]};
  resources ThreeOp = { next_pc, rs1, rs2 : rd[..rd]};
  opcodes {
    addi{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "addi", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIAdd";
    slti{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "slti", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISlt";
    sltiu{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "sltiu", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISltu";
    andi{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "andi", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIAnd";
    ori{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "ori", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIOr";
    xori{: rs1, I_imm12 : rd},
      resources: TwoOp,
      disasm: "xori", "%rd, %rs1, %I_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIXor";
    slli{: rs1, I_uimm5 : rd},
      resources: TwoOp,
      disasm: "slli", "%rd, %rs1, 0x%(I_uimm5:x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISll";
    srli{: rs1, I_uimm5 : rd},
      resources: TwoOp,
      disasm: "srli", "%rd  %rs1, 0x%(I_uimm5:x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISrl";
    srai{: rs1, I_uimm5 : rd},
      resources: TwoOp,
      disasm: "srai", "%rd, %rs1, 0x%(I_uimm5:x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISra";
    lui{: U_imm20 : rd},
      resources: { next_pc : rd[0..]},
      disasm: "lui", "%rd, 0x%(U_imm20:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILui";
    auipc{: U_imm20 : rd},
      resources: { next_pc : rd[0..]},
      disasm: "auipc", "%rd, 0x%(U_imm20:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIAuipc";
    add{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "add", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIAdd";
    slt{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "slt", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISlt";
    sltu{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "sltu", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISltu";
    and{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "and", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIAnd";
    or{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "or", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIOr";
    xor{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "xor", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIXor";
    sll{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "sll", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISll";
    srl{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "srl", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISrl";
    sub{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "sub", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISub";
    sra{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "sra", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISra";
    nop{},
      disasm: "nop",
      semfunc: "&mpact::sim::riscv::RiscVINop";
    hint{},
      disasm: "hint",
      semfunc: "&mpact::sim::riscv::RiscVINop";
    jal{: J_imm20 : next_pc, rd},
      resources: { next_pc : next_pc[0..], rd[0..]},
      disasm: "jal", "%rd, %(@+J_imm20:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIJal";
    jalr{: rs1, J_imm12 : next_pc, rd},
      resources: { next_pc, rs1 : next_pc[0..], rd[0..]},
      disasm: "jalr", "%rd, %rs1, %J_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIJalr";
    j{: J_imm20 : next_pc, rd},
      resources: { next_pc : next_pc[0..], rd[0..]},
      disasm: "j", "%(@+J_imm20:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIJal";
    jr{: rs1, J_imm12 : next_pc, rd},
      resources: { next_pc, rs1 : next_pc[0..], rd[0..]},
      disasm: "jr", "%rs1, %J_imm12",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIJalr";
    beq{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "beq", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBeq";
    bne{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "bne", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBne";
    blt{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "blt", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBlt";
    bltu{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "bltu", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBltu";
    bge{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "bge", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBge";
    bgeu{: rs1, rs2, B_imm12 : next_pc},
      resources: { next_pc, rs1, rs2 : next_pc[0..]},
      disasm: "bgeu", "%rs1, %rs2, %(@+B_imm12:08x)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVIBgeu";
    lw{(: rs1, I_imm12), (: : rd)},
      resources: { next_pc, rs1 : rd[0..]},
      disasm: "lw", "%rd, %I_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILw", "&mpact::sim::riscv::RV32::RiscVILwChild";
    lh{(: rs1, I_imm12 :), (: : rd)},
      resources: { next_pc, rs1 : rd[0..]},
      disasm: "lh", "%rd, %I_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILh", "&mpact::sim::riscv::RV32::RiscVILhChild";
    lhu{(: rs1, I_imm12 :), (: : rd)},
      resources: { next_pc, rs1 : rd[0..]},
      disasm: "lhu", "%rd, %I_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILhu", "&mpact::sim::riscv::RV32::RiscVILhuChild";
    lb{(: rs1, I_imm12 :), (: : rd)},
      resources: { next_pc, rs1 : rd[0..]},
      disasm: "lb", "%rd, %I_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILb", "&mpact::sim::riscv::RV32::RiscVILbChild";
    lbu{(: rs1, I_imm12 :), (: : rd)},
      resources: { next_pc, rs1 : rd[0..]},
      disasm: "lbu", "%rd, %I_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVILbu", "&mpact::sim::riscv::RV32::RiscVILbuChild";
    sw{: rs1, S_imm12, rs2 : },
      resources: { next_pc, rs1, rs2 : },
      disasm: "sw", "%rs2, %S_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISw";
    sh{: rs1, S_imm12, rs2 : },
      resources: { next_pc, rs1, rs2 : },
      disasm: "sh", "%rs2, %S_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISh";
    sb{: rs1, S_imm12, rs2 : },
      resources: { next_pc, rs1, rs2 : },
      disasm: "sb", "%rs2, %S_imm12(%rs1)",
      semfunc: "&mpact::sim::riscv::RV32::RiscVISb";
    fence{: I_imm12 : },
      disasm: "fence",
      semfunc: "&mpact::sim::riscv::RiscVIFence";
    ecall{},
      disasm: "ecall",
      semfunc: "&mpact::sim::riscv::RiscVIEcall";
    ebreak{},
      disasm: "ebreak",
      semfunc: "&mpact::sim::riscv::RiscVIEbreak";
  }
}

// RiscV32 multiply/divide instructions.
slot riscv32m {
  includes {
    #include "riscv/riscv_m_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  resources ThreeOp = { next_pc, rs1, rs2 : rd[..rd]};
  opcodes {
    mul{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "mul", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MMul";
    mulh{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "mulh", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MMulh";
    mulhu{: rs1, rs2: rd},
      resources: ThreeOp,
      disasm: "mulhu", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MMulhu";
    mulhsu{: rs1, rs2: rd},
      resources: ThreeOp,
      disasm: "mulhsu", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MMulhsu";
    div{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "div", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MDiv";
    divu{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "divu", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MDivu";
    rem{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "rem", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MRem";
    remu{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "remu", "%rd, %rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RV32::MRemu";
  }
}

// RiscV32 CSR manipulation instructions.
slot zicsr {
  includes {
    #include "riscv/riscv_zicsr_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    csrrw{: rs1, csr : rd, csr},
      resources: { next_pc, rs1, csr : rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrw",
      disasm: "csrw", "%rd, %csr, %rs1";
    csrrs{: rs1, csr : rd, csr},
      resources: { next_pc, rs1, csr : rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrs",
      disasm: "csrs", "%rd, %csr, %rs1";
    csrrc{: rs1, csr : rd, csr},
      resources: { next_pc, rs1, csr : rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrc",
      disasm: "csrc", "%rd, %csr, %rs1";
    csrrs_nr{: rs1, csr : rd, csr},
      resources: { next_pc, rs1, csr : rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrs",
      disasm: "csrs", "%csr, %rs1";
    csrrc_nr{: rs1, csr : rd, csr},
      resources: { next_pc, rs1, csr : rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrc",
      disasm: "csrc", "%csr, %rs1";
    csrrw_nr{: rs1, csr : csr},
      resources: { next_pc, rs1: csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrwNr", // rd == 0 (x0).
      disasm: "csrw", "%csr, %rs1";
    csrrs_nw{: csr : rd},
      resources: { next_pc, csr: rd[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrNw", // rs1 == 0 (x0).
      disasm: "csrs", "%rd, %csr";
    csrrc_nw{: csr : rd},
      resources: { next_pc, csr: rd[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrNw", // rs1 == 0 (x0).
      disasm: "csrc", "%rd, %csr";
    csrrwi{: CSR_uimm5, csr : rd, csr},
      resources: { next_pc, csr: rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrw",
      disasm: "csrwi", "%rd, %csr, %CSR_uimm5";
    csrrsi{: CSR_uimm5, csr : rd, csr},
      resources: { next_pc, csr: rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrs",
      disasm: "csrsi", "%rd, %csr, %CSR_uimm5";
    csrrci{: CSR_uimm5, csr : rd, csr},
      resources: { next_pc, csr: rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrc",
      disasm: "csrci", "%rd, %csr, %CSR_uimm5";
    csrrsi_nr{: CSR_uimm5, csr : rd, csr},
      resources: { next_pc, csr: rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrs",
      disasm: "csrsi", "%csr, %CSR_uimm5";
    csrrci_nr{: CSR_uimm5, csr : rd, csr},
      resources: { next_pc, csr: rd[0..], csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrc",
      disasm: "csrci", "%csr, %CSR_uimm5";
    csrrwi_nr{: CSR_uimm5, csr : csr},
      resources: { next_pc : csr[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrwNr",  // rd == 0 (x0).
      disasm: "csrrwi", "%csr, %CSR_uimm5";
    csrrsi_nw{: csr : rd},
      resources: { next_pc, csr : rd[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrNw", // uimm5 == 0.
      disasm: "csrsi", "%rd, %csr, 0";
    csrrci_nw{: csr : rd},
      resources: { next_pc, csr : rd[0..]},
      semfunc: "&mpact::sim::riscv::RV32::RiscVZiCsrrNw", // uimm5 == 0.
      disasm: "csrwi", "%rd, %csr, 0";
  }
}

// Instruction fence.
slot zfencei {
  includes {
    #include "riscv/riscv_zfencei_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    fencei{: I_imm12 : },
      disasm: "fence.i",
      semfunc: "&mpact::sim::riscv::RiscVZFencei";
  }
}

// Privileged instructions.
slot privileged {
  includes {
    #include "riscv/riscv_priv_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    uret{: : next_pc},
      disasm: "uret",
      semfunc: "&mpact::sim::riscv::RV32::RiscVPrivURet";
    sret{: : next_pc},
      disasm: "sret",
      semfunc: "&mpact::sim::riscv::RV32::RiscVPrivSRet";
    mret{: : next_pc},
      disasm: "mret",
      semfunc: "&mpact::sim::riscv::RV32::RiscVPrivMRet";
    wfi{},
      disasm: "wfi",
      semfunc: "&mpact::sim::riscv::RiscVPrivWfi";
    mpause{},
      disasm: "mpause",
      // mpause is the software breakpoint to terminate the program.
      semfunc: "&KelvinIMpause";
    // The sfence instruction has 4 behaviors depending on if rs1 and/or rs2
    // are 0. These behaviors are split into 4 instructions.
    sfence_vma_zz{: rs1, rs2},
      resources: {},
      disasm: "sfence.vma", "%rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RiscVPrivSFenceVmaZZ";
    sfence_vma_zn{: rs1, rs2},
      resources: {rs2},
      disasm: "sfence.vma", "%rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RiscVPrivSFenceVmaZN";
    sfence_vma_nz{: rs1, rs2},
      resources: { rs1 },
      disasm: "sfence.vma", "%rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RiscVPrivSFenceVmaNZ";
    sfence_vma_nn{: rs1, rs2},
      resources: {rs1, rs2},
      disasm: "sfence.vma", "%rs1, %rs2",
      semfunc: "&mpact::sim::riscv::RiscVPrivSFenceVmaNN";
    // Skipping hypervisor memory management instructions for now.
  }
}

// Kelvin simd instructions:
// https://spacebeaker.googlesource.com/shodan/experimental-kelvin/+/refs/heads/master/docs/arch/isa.md
slot kelvin_arith {
  includes {
    #include "sim/kelvin_instructions.h"
    #include "sim/kelvin_vector_instructions.h"
    #include "sim/kelvin_vector_memory_instructions.h"
    #include "absl/functional/bind_front.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    // vadd
    vadd_b_vv{: vs1, vs2 : vd},
    disasm: "vadd.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd_b_vv_m{: vs1, vs2 : vd},
    disasm: "vadd.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd_h_vv{: vs1, vs2 : vd},
    disasm: "vadd.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd_h_vv_m{: vs1, vs2 : vd},
    disasm: "vadd.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd_w_vv{: vs1, vs2 : vd},
    disasm: "vadd.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd_w_vv_m{: vs1, vs2 : vd},
    disasm: "vadd.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd_b_vx{: vs1, vs2 : vd},
    disasm: "vadd.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd_b_vx_m{: vs1, vs2 : vd},
    disasm: "vadd.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadd_h_vx{: vs1, vs2 : vd},
    disasm: "vadd.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd_h_vx_m{: vs1, vs2 : vd},
    disasm: "vadd.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadd_w_vx{: vs1, vs2 : vd},
    disasm: "vadd.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd_w_vx_m{: vs1, vs2 : vd},
    disasm: "vadd.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vsub
    vsub_b_vv{: vs1, vs2 : vd},
    disasm: "vsub.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsub_b_vv_m{: vs1, vs2 : vd},
    disasm: "vsub.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsub_h_vv{: vs1, vs2 : vd},
    disasm: "vsub.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsub_h_vv_m{: vs1, vs2 : vd},
    disasm: "vsub.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsub_w_vv{: vs1, vs2 : vd},
    disasm: "vsub.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsub_w_vv_m{: vs1, vs2 : vd},
    disasm: "vsub.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsub_b_vx{: vs1, vs2 : vd},
    disasm: "vsub.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsub_b_vx_m{: vs1, vs2 : vd},
    disasm: "vsub.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsub_h_vx{: vs1, vs2 : vd},
    disasm: "vsub.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsub_h_vx_m{: vs1, vs2 : vd},
    disasm: "vsub.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsub_w_vx{: vs1, vs2 : vd},
    disasm: "vsub.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsub_w_vx_m{: vs1, vs2 : vd},
    disasm: "vsub.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSub<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vrsub
    vrsub_b_vv{: vs1, vs2 : vd},
    disasm: "vrsub.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vrsub_b_vv_m{: vs1, vs2 : vd},
    disasm: "vrsub.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vrsub_h_vv{: vs1, vs2 : vd},
    disasm: "vrsub.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vrsub_h_vv_m{: vs1, vs2 : vd},
    disasm: "vrsub.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vrsub_w_vv{: vs1, vs2 : vd},
    disasm: "vrsub.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vrsub_w_vv_m{: vs1, vs2 : vd},
    disasm: "vrsub.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vrsub_b_vx{: vs1, vs2 : vd},
    disasm: "vrsub.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vrsub_b_vx_m{: vs1, vs2 : vd},
    disasm: "vrsub.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vrsub_h_vx{: vs1, vs2 : vd},
    disasm: "vrsub.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vrsub_h_vx_m{: vs1, vs2 : vd},
    disasm: "vrsub.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vrsub_w_vx{: vs1, vs2 : vd},
    disasm: "vrsub.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vrsub_w_vx_m{: vs1, vs2 : vd},
    disasm: "vrsub.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVRSub<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // veq
    veq_b_vv{: vs1, vs2 : vd},
    disasm: "veq.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    veq_b_vv_m{: vs1, vs2 : vd},
    disasm: "veq.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    veq_h_vv{: vs1, vs2 : vd},
    disasm: "veq.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    veq_h_vv_m{: vs1, vs2 : vd},
    disasm: "veq.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    veq_w_vv{: vs1, vs2 : vd},
    disasm: "veq.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    veq_w_vv_m{: vs1, vs2 : vd},
    disasm: "veq.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    veq_b_vx{: vs1, vs2 : vd},
    disasm: "veq.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    veq_b_vx_m{: vs1, vs2 : vd},
    disasm: "veq.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    veq_h_vx{: vs1, vs2 : vd},
    disasm: "veq.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    veq_h_vx_m{: vs1, vs2 : vd},
    disasm: "veq.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    veq_w_vx{: vs1, vs2 : vd},
    disasm: "veq.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    veq_w_vx_m{: vs1, vs2 : vd},
    disasm: "veq.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVEq<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vne
    vne_b_vv{: vs1, vs2 : vd},
    disasm: "vne.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vne_b_vv_m{: vs1, vs2 : vd},
    disasm: "vne.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vne_h_vv{: vs1, vs2 : vd},
    disasm: "vne.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vne_h_vv_m{: vs1, vs2 : vd},
    disasm: "vne.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vne_w_vv{: vs1, vs2 : vd},
    disasm: "vne.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vne_w_vv_m{: vs1, vs2 : vd},
    disasm: "vne.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vne_b_vx{: vs1, vs2 : vd},
    disasm: "vne.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vne_b_vx_m{: vs1, vs2 : vd},
    disasm: "vne.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vne_h_vx{: vs1, vs2 : vd},
    disasm: "vne.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vne_h_vx_m{: vs1, vs2 : vd},
    disasm: "vne.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vne_w_vx{: vs1, vs2 : vd},
    disasm: "vne.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vne_w_vx_m{: vs1, vs2 : vd},
    disasm: "vne.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVNe<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vlt
    vlt_b_vv{: vs1, vs2 : vd},
    disasm: "vlt.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_b_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_h_vv{: vs1, vs2 : vd},
    disasm: "vlt.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_h_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_w_vv{: vs1, vs2 : vd},
    disasm: "vlt.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_w_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_b_vx{: vs1, vs2 : vd},
    disasm: "vlt.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_b_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vlt_h_vx{: vs1, vs2 : vd},
    disasm: "vlt.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_h_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vlt_w_vx{: vs1, vs2 : vd},
    disasm: "vlt.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_w_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vltu
    vlt_u_b_vv{: vs1, vs2 : vd},
    disasm: "vlt.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_u_h_vv{: vs1, vs2 : vd},
    disasm: "vlt.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_u_w_vv{: vs1, vs2 : vd},
    disasm: "vlt.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vlt_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vlt.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vlt_u_b_vx{: vs1, vs2 : vd},
    disasm: "vlt.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vlt_u_h_vx{: vs1, vs2 : vd},
    disasm: "vlt.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vlt_u_w_vx{: vs1, vs2 : vd},
    disasm: "vlt.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vlt_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vlt.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVLt<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vle
    vle_b_vv{: vs1, vs2 : vd},
    disasm: "vle.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_b_vv_m{: vs1, vs2 : vd},
    disasm: "vle.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_h_vv{: vs1, vs2 : vd},
    disasm: "vle.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_h_vv_m{: vs1, vs2 : vd},
    disasm: "vle.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_w_vv{: vs1, vs2 : vd},
    disasm: "vle.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_w_vv_m{: vs1, vs2 : vd},
    disasm: "vle.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_b_vx{: vs1, vs2 : vd},
    disasm: "vle.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_b_vx_m{: vs1, vs2 : vd},
    disasm: "vle.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vle_h_vx{: vs1, vs2 : vd},
    disasm: "vle.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_h_vx_m{: vs1, vs2 : vd},
    disasm: "vle.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vle_w_vx{: vs1, vs2 : vd},
    disasm: "vle.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_w_vx_m{: vs1, vs2 : vd},
    disasm: "vle.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vleu
    vle_u_b_vv{: vs1, vs2 : vd},
    disasm: "vle.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vle.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_u_h_vv{: vs1, vs2 : vd},
    disasm: "vle.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vle.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_u_w_vv{: vs1, vs2 : vd},
    disasm: "vle.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vle_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vle.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vle_u_b_vx{: vs1, vs2 : vd},
    disasm: "vle.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vle.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vle_u_h_vx{: vs1, vs2 : vd},
    disasm: "vle.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vle.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vle_u_w_vx{: vs1, vs2 : vd},
    disasm: "vle.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vle_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vle.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVLe<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vgt
    vgt_b_vv{: vs1, vs2 : vd},
    disasm: "vgt.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_b_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_h_vv{: vs1, vs2 : vd},
    disasm: "vgt.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_h_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_w_vv{: vs1, vs2 : vd},
    disasm: "vgt.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_w_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_b_vx{: vs1, vs2 : vd},
    disasm: "vgt.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_b_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vgt_h_vx{: vs1, vs2 : vd},
    disasm: "vgt.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_h_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vgt_w_vx{: vs1, vs2 : vd},
    disasm: "vgt.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_w_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vgtu
    vgt_u_b_vv{: vs1, vs2 : vd},
    disasm: "vgt.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_u_h_vv{: vs1, vs2 : vd},
    disasm: "vgt.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_u_w_vv{: vs1, vs2 : vd},
    disasm: "vgt.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vgt_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vgt.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vgt_u_b_vx{: vs1, vs2 : vd},
    disasm: "vgt.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vgt_u_h_vx{: vs1, vs2 : vd},
    disasm: "vgt.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vgt_u_w_vx{: vs1, vs2 : vd},
    disasm: "vgt.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vgt_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vgt.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVGt<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vge
    vge_b_vv{: vs1, vs2 : vd},
    disasm: "vge.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_b_vv_m{: vs1, vs2 : vd},
    disasm: "vge.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_h_vv{: vs1, vs2 : vd},
    disasm: "vge.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_h_vv_m{: vs1, vs2 : vd},
    disasm: "vge.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_w_vv{: vs1, vs2 : vd},
    disasm: "vge.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_w_vv_m{: vs1, vs2 : vd},
    disasm: "vge.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_b_vx{: vs1, vs2 : vd},
    disasm: "vge.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_b_vx_m{: vs1, vs2 : vd},
    disasm: "vge.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vge_h_vx{: vs1, vs2 : vd},
    disasm: "vge.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_h_vx_m{: vs1, vs2 : vd},
    disasm: "vge.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vge_w_vx{: vs1, vs2 : vd},
    disasm: "vge.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_w_vx_m{: vs1, vs2 : vd},
    disasm: "vge.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vgeu
    vge_u_b_vv{: vs1, vs2 : vd},
    disasm: "vge.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vge.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_u_h_vv{: vs1, vs2 : vd},
    disasm: "vge.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vge.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_u_w_vv{: vs1, vs2 : vd},
    disasm: "vge.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vge_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vge.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vge_u_b_vx{: vs1, vs2 : vd},
    disasm: "vge.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vge.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vge_u_h_vx{: vs1, vs2 : vd},
    disasm: "vge.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vge.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vge_u_w_vx{: vs1, vs2 : vd},
    disasm: "vge.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vge_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vge.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVGe<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vabsd
    vabsd_b_vv{: vs1, vs2 : vd},
    disasm: "vabsd.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_b_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_h_vv{: vs1, vs2 : vd},
    disasm: "vabsd.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_h_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_w_vv{: vs1, vs2 : vd},
    disasm: "vabsd.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_w_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_b_vx{: vs1, vs2 : vd},
    disasm: "vabsd.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_b_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vabsd_h_vx{: vs1, vs2 : vd},
    disasm: "vabsd.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_h_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vabsd_w_vx{: vs1, vs2 : vd},
    disasm: "vabsd.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_w_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vabsdu
    vabsd_u_b_vv{: vs1, vs2 : vd},
    disasm: "vabsd.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_u_h_vv{: vs1, vs2 : vd},
    disasm: "vabsd.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_u_w_vv{: vs1, vs2 : vd},
    disasm: "vabsd.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vabsd_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vabsd.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vabsd_u_b_vx{: vs1, vs2 : vd},
    disasm: "vabsd.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vabsd_u_h_vx{: vs1, vs2 : vd},
    disasm: "vabsd.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vabsd_u_w_vx{: vs1, vs2 : vd},
    disasm: "vabsd.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vabsd_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vabsd.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVAbsd<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vmax
    vmax_b_vv{: vs1, vs2 : vd},
    disasm: "vmax.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_b_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_h_vv{: vs1, vs2 : vd},
    disasm: "vmax.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_h_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_w_vv{: vs1, vs2 : vd},
    disasm: "vmax.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_w_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_b_vx{: vs1, vs2 : vd},
    disasm: "vmax.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_b_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmax_h_vx{: vs1, vs2 : vd},
    disasm: "vmax.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_h_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmax_w_vx{: vs1, vs2 : vd},
    disasm: "vmax.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_w_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vmaxu
    vmax_u_b_vv{: vs1, vs2 : vd},
    disasm: "vmax.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_u_h_vv{: vs1, vs2 : vd},
    disasm: "vmax.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_u_w_vv{: vs1, vs2 : vd},
    disasm: "vmax.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmax_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vmax.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmax_u_b_vx{: vs1, vs2 : vd},
    disasm: "vmax.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmax_u_h_vx{: vs1, vs2 : vd},
    disasm: "vmax.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmax_u_w_vx{: vs1, vs2 : vd},
    disasm: "vmax.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmax_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vmax.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVMax<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vmin
    vmin_b_vv{: vs1, vs2 : vd},
    disasm: "vmin.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_b_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_h_vv{: vs1, vs2 : vd},
    disasm: "vmin.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_h_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_w_vv{: vs1, vs2 : vd},
    disasm: "vmin.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_w_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_b_vx{: vs1, vs2 : vd},
    disasm: "vmin.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_b_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmin_h_vx{: vs1, vs2 : vd},
    disasm: "vmin.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_h_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmin_w_vx{: vs1, vs2 : vd},
    disasm: "vmin.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_w_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vminu
    vmin_u_b_vv{: vs1, vs2 : vd},
    disasm: "vmin.b.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_u_b_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.b.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_u_h_vv{: vs1, vs2 : vd},
    disasm: "vmin.h.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_u_h_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.h.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_u_w_vv{: vs1, vs2 : vd},
    disasm: "vmin.w.u.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmin_u_w_vv_m{: vs1, vs2 : vd},
    disasm: "vmin.w.u.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmin_u_b_vx{: vs1, vs2 : vd},
    disasm: "vmin.b.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_u_b_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.b.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmin_u_h_vx{: vs1, vs2 : vd},
    disasm: "vmin.h.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_u_h_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.h.u.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmin_u_w_vx{: vs1, vs2 : vd},
    disasm: "vmin.w.u.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmin_u_w_vx_m{: vs1, vs2 : vd},
    disasm: "vmin.w.u.vx.m", "%vd, %vs1,V %vs2",
    semfunc: "absl::bind_front(&KelvinVMin<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";
    // vadd3
    vadd3_b_vv{: vs1, vs2, vd : vd},
    disasm: "vadd3.b.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd3_b_vv_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.b.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd3_h_vv{: vs1, vs2, vd : vd},
    disasm: "vadd3.h.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd3_h_vv_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.h.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd3_w_vv{: vs1, vs2, vd : vd},
    disasm: "vadd3.w.vv", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadd3_w_vv_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.w.vv.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadd3_b_vx{: vs1, vs2, vd : vd},
    disasm: "vadd3.b.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd3_b_vx_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.b.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadd3_h_vx{: vs1, vs2, vd : vd},
    disasm: "vadd3.h.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd3_h_vx_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.h.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadd3_w_vx{: vs1, vs2, vd : vd},
    disasm: "vadd3.w.vx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadd3_w_vx_m{: vs1, vs2, vd : vd},
    disasm: "vadd3.w.vx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVAdd3<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vadds
    vadds_b_vv{: vs1, vs2 : vd},
      disasm: "vadds.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_b_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_h_vv{: vs1, vs2 : vd},
      disasm: "vadds.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_h_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_w_vv{: vs1, vs2 : vd},
      disasm: "vadds.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_w_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_b_vx{: vs1, vs2 : vd},
      disasm: "vadds.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_b_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadds_h_vx{: vs1, vs2 : vd},
      disasm: "vadds.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_h_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadds_w_vx{: vs1, vs2 : vd},
      disasm: "vadds.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_w_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAdds<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vaddsu
    vadds_u_b_vv{: vs1, vs2 : vd},
      disasm: "vadds.b.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_u_b_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.b.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_u_h_vv{: vs1, vs2 : vd},
      disasm: "vadds.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_u_h_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_u_w_vv{: vs1, vs2 : vd},
      disasm: "vadds.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vadds_u_w_vv_m{: vs1, vs2 : vd},
      disasm: "vadds.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vadds_u_b_vx{: vs1, vs2 : vd},
      disasm: "vadds.b.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_u_b_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.b.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadds_u_h_vx{: vs1, vs2 : vd},
      disasm: "vadds.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_u_h_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vadds_u_w_vx{: vs1, vs2 : vd},
      disasm: "vadds.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vadds_u_w_vx_m{: vs1, vs2 : vd},
      disasm: "vadds.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddsu<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsubs
    vsubs_b_vv{: vs1, vs2 : vd},
      disasm: "vsubs.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_h_vv{: vs1, vs2 : vd},
      disasm: "vsubs.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_w_vv{: vs1, vs2 : vd},
      disasm: "vsubs.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_b_vx{: vs1, vs2 : vd},
      disasm: "vsubs.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubs_h_vx{: vs1, vs2 : vd},
      disasm: "vsubs.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubs_w_vx{: vs1, vs2 : vd},
      disasm: "vsubs.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubs<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsubsu
    vsubs_u_b_vv{: vs1, vs2 : vd},
      disasm: "vsubs.b.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_u_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.b.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_u_h_vv{: vs1, vs2 : vd},
      disasm: "vsubs.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_u_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_u_w_vv{: vs1, vs2 : vd},
      disasm: "vsubs.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubs_u_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsubs.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubs_u_b_vx{: vs1, vs2 : vd},
      disasm: "vsubs.b.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_u_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.b.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubs_u_h_vx{: vs1, vs2 : vd},
      disasm: "vsubs.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_u_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubs_u_w_vx{: vs1, vs2 : vd},
      disasm: "vsubs.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubs_u_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsubs.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubsu<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vaddw
    vaddw_h_vv{: vs1, vs2 : vd},
      disasm: "vaddw.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vaddw_h_vv_m{: vs1, vs2 : vd},
      disasm: "vaddw.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vaddw_w_vv{: vs1, vs2 : vd},
      disasm: "vaddw.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vaddw_w_vv_m{: vs1, vs2 : vd},
      disasm: "vaddw.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vaddw_h_vx{: vs1, vs2 : vd},
      disasm: "vaddw.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vaddw_h_vx_m{: vs1, vs2 : vd},
      disasm: "vaddw.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vaddw_w_vx{: vs1, vs2 : vd},
      disasm: "vaddw.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vaddw_w_vx_m{: vs1, vs2 : vd},
      disasm: "vaddw.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vaddwu
    vaddw_h_u_vv{: vs1, vs2 : vd},
      disasm: "vaddw.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vaddw_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vaddw.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vaddw_w_u_vv{: vs1, vs2 : vd},
      disasm: "vaddw.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vaddw_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vaddw.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vaddw_h_u_vx{: vs1, vs2 : vd},
      disasm: "vaddw.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vaddw_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vaddw.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vaddw_w_u_vx{: vs1, vs2 : vd},
      disasm: "vaddw.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vaddw_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vaddw.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAddw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsubw
    vsubw_h_vv{: vs1, vs2 : vd},
      disasm: "vsubw.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubw_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsubw.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubw_w_vv{: vs1, vs2 : vd},
      disasm: "vsubw.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubw_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsubw.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubw_h_vx{: vs1, vs2 : vd},
      disasm: "vsubw.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubw_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsubw.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubw_w_vx{: vs1, vs2 : vd},
      disasm: "vsubw.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubw_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsubw.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsubwu
    vsubw_h_u_vv{: vs1, vs2 : vd},
      disasm: "vsubw.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubw_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vsubw.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubw_w_u_vv{: vs1, vs2 : vd},
      disasm: "vsubw.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsubw_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vsubw.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsubw_h_u_vx{: vs1, vs2 : vd},
      disasm: "vsubw.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubw_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vsubw.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsubw_w_u_vx{: vs1, vs2 : vd},
      disasm: "vsubw.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsubw_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vsubw.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSubw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";

   //vacc
    vacc_h_vv{: vs1, vs2 : vd},
      disasm: "vacc.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vacc_h_vv_m{: vs1, vs2 : vd},
      disasm: "vacc.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vacc_w_vv{: vs1, vs2 : vd},
      disasm: "vacc.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vacc_w_vv_m{: vs1, vs2 : vd},
      disasm: "vacc.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vacc_h_vx{: vs1, vs2 : vd},
      disasm: "vacc.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vacc_h_vx_m{: vs1, vs2 : vd},
      disasm: "vacc.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vacc_w_vx{: vs1, vs2 : vd},
      disasm: "vacc.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vacc_w_vx_m{: vs1, vs2 : vd},
      disasm: "vacc.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vaccu
    vacc_h_u_vv{: vs1, vs2 : vd},
      disasm: "vacc.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vacc_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vacc.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vacc_w_u_vv{: vs1, vs2 : vd},
      disasm: "vacc.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vacc_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vacc.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vacc_h_u_vx{: vs1, vs2 : vd},
      disasm: "vacc.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vacc_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vacc.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vacc_w_u_vx{: vs1, vs2 : vd},
      disasm: "vacc.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vacc_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vacc.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAcc<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";

   //vpadd
    vpadd_h_v{: vs1 : vd},
      disasm: "vpadd.h.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int16_t, int8_t>, /*strip_mine*/ false)";
    vpadd_h_v_m{: vs1 : vd},
      disasm: "vpadd.h.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int16_t, int8_t>, /*strip_mine*/ true)";
    vpadd_w_v{: vs1 : vd},
      disasm: "vpadd.w.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int32_t, int16_t>, /*strip_mine*/ false)";
    vpadd_w_v_m{: vs1 : vd},
      disasm: "vpadd.w.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int32_t, int16_t>, /*strip_mine*/ true)";

   //vpaddu
    vpadd_h_u_v{: vs1 : vd},
      disasm: "vpadd.h.u.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int16_t, int8_t>, /*strip_mine*/ false)";
    vpadd_h_u_v_m{: vs1 : vd},
      disasm: "vpadd.h.u.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int16_t, int8_t>, /*strip_mine*/ true)";
    vpadd_w_u_v{: vs1 : vd},
      disasm: "vpadd.w.u.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int32_t, int16_t>, /*strip_mine*/ false)";
    vpadd_w_u_v_m{: vs1 : vd},
      disasm: "vpadd.w.u.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPadd<int32_t, int16_t>, /*strip_mine*/ true)";

   //vpsub
    vpsub_h_v{: vs1 : vd},
      disasm: "vpsub.h.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int16_t, int8_t>, /*strip_mine*/ false)";
    vpsub_h_v_m{: vs1 : vd},
      disasm: "vpsub.h.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int16_t, int8_t>, /*strip_mine*/ true)";
    vpsub_w_v{: vs1 : vd},
      disasm: "vpsub.w.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int32_t, int16_t>, /*strip_mine*/ false)";
    vpsub_w_v_m{: vs1 : vd},
      disasm: "vpsub.w.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int32_t, int16_t>, /*strip_mine*/ true)";

    //vpsubu
    vpsub_h_u_v{: vs1 : vd},
      disasm: "vpsub.h.u.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int16_t, int8_t>, /*strip_mine*/ false)";
    vpsub_h_u_v_m{: vs1 : vd},
      disasm: "vpsub.h.u.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int16_t, int8_t>, /*strip_mine*/ true)";
    vpsub_w_u_v{: vs1 : vd},
      disasm: "vpsub.w.u.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int32_t, int16_t>, /*strip_mine*/ false)";
    vpsub_w_u_v_m{: vs1 : vd},
      disasm: "vpsub.w.u.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVPsub<int32_t, int16_t>, /*strip_mine*/ true)";

    //vhadd
    vhadd_b_vv{: vs1, vs2 : vd},
      disasm: "vhadd.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_b_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_h_vv{: vs1, vs2 : vd},
      disasm: "vhadd.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_h_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_w_vv{: vs1, vs2 : vd},
      disasm: "vhadd.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_w_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_b_vx{: vs1, vs2 : vd},
      disasm: "vhadd.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_b_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhadd_h_vx{: vs1, vs2 : vd},
      disasm: "vhadd.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_h_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhadd_w_vx{: vs1, vs2 : vd},
      disasm: "vhadd.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_w_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vhadd.r
    vhadd_b_r_vv{: vs1, vs2 : vd},
      disasm: "vhadd.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_h_r_vv{: vs1, vs2 : vd},
      disasm: "vhadd.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_w_r_vv{: vs1, vs2 : vd},
      disasm: "vhadd.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_b_r_vx{: vs1, vs2 : vd},
      disasm: "vhadd.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhadd_h_r_vx{: vs1, vs2 : vd},
      disasm: "vhadd.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhadd_w_r_vx{: vs1, vs2 : vd},
      disasm: "vhadd.w.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_w_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vhadd.u
    vhadd_b_u_vv{: vs1, vs2 : vd},
      disasm: "vhadd.b.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_b_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_h_u_vv{: vs1, vs2 : vd},
      disasm: "vhadd.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_w_u_vv{: vs1, vs2 : vd},
      disasm: "vhadd.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhadd_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhadd_b_u_vx{: vs1, vs2 : vd},
      disasm: "vhadd.b.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_b_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhadd_h_u_vx{: vs1, vs2 : vd},
      disasm: "vhadd.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhadd_w_u_vx{: vs1, vs2 : vd},
      disasm: "vhadd.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhadd_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vhadd.ru
    vhadd_b_ur_vv{: vs1, vs2 : vd},
      disasm: "vhadd.b.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_b_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_h_ur_vv{: vs1, vs2 : vd},
      disasm: "vhadd.h.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_h_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_w_ur_vv{: vs1, vs2 : vd},
      disasm: "vhadd.w.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhadd_w_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhadd_b_ur_vx{: vs1, vs2 : vd},
      disasm: "vhadd.b.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_b_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.b.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhadd_h_ur_vx{: vs1, vs2 : vd},
      disasm: "vhadd.h.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_h_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.h.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhadd_w_ur_vx{: vs1, vs2 : vd},
      disasm: "vhadd.w.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhadd_w_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhadd.w.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHadd<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vhsub
    vhsub_b_vv{: vs1, vs2 : vd},
      disasm: "vhsub.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_b_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_h_vv{: vs1, vs2 : vd},
      disasm: "vhsub.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_h_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_w_vv{: vs1, vs2 : vd},
      disasm: "vhsub.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_w_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_b_vx{: vs1, vs2 : vd},
      disasm: "vhsub.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_b_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhsub_h_vx{: vs1, vs2 : vd},
      disasm: "vhsub.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_h_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhsub_w_vx{: vs1, vs2 : vd},
      disasm: "vhsub.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_w_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vhsub.r
    vhsub_b_r_vv{: vs1, vs2 : vd},
      disasm: "vhsub.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_h_r_vv{: vs1, vs2 : vd},
      disasm: "vhsub.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_w_r_vv{: vs1, vs2 : vd},
      disasm: "vhsub.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_b_r_vx{: vs1, vs2 : vd},
      disasm: "vhsub.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhsub_h_r_vx{: vs1, vs2 : vd},
      disasm: "vhsub.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhsub_w_r_vx{: vs1, vs2 : vd},
      disasm: "vhsub.w.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_w_r_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vhsub.u
    vhsub_b_u_vv{: vs1, vs2 : vd},
      disasm: "vhsub.b.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_b_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_h_u_vv{: vs1, vs2 : vd},
      disasm: "vhsub.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_w_u_vv{: vs1, vs2 : vd},
      disasm: "vhsub.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vhsub_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vhsub_b_u_vx{: vs1, vs2 : vd},
      disasm: "vhsub.b.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_b_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhsub_h_u_vx{: vs1, vs2 : vd},
      disasm: "vhsub.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vhsub_w_u_vx{: vs1, vs2 : vd},
      disasm: "vhsub.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vhsub_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vhsub.ru
    vhsub_b_ur_vv{: vs1, vs2 : vd},
      disasm: "vhsub.b.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_b_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_h_ur_vv{: vs1, vs2 : vd},
      disasm: "vhsub.h.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_h_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_w_ur_vv{: vs1, vs2 : vd},
      disasm: "vhsub.w.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vhsub_w_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vhsub_b_ur_vx{: vs1, vs2 : vd},
      disasm: "vhsub.b.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_b_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.b.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhsub_h_ur_vx{: vs1, vs2 : vd},
      disasm: "vhsub.h.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_h_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.h.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vhsub_w_ur_vx{: vs1, vs2 : vd},
      disasm: "vhsub.w.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vhsub_w_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vhsub.w.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVHsub<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vand
    vand_vv{: vs1, vs2 : vd},
      disasm: "vand.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vand_vv_m{: vs1, vs2 : vd},
      disasm: "vand.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vand_b_vx{: vs1, vs2 : vd},
      disasm: "vand.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vand_b_vx_m{: vs1, vs2 : vd},
      disasm: "vand.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vand_h_vx{: vs1, vs2 : vd},
      disasm: "vand.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vand_h_vx_m{: vs1, vs2 : vd},
      disasm: "vand.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vand_w_vx{: vs1, vs2 : vd},
      disasm: "vand.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vand_w_vx_m{: vs1, vs2 : vd},
      disasm: "vand.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVAnd<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vor
    vor_vv{: vs1, vs2 : vd},
      disasm: "vor.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vor_vv_m{: vs1, vs2 : vd},
      disasm: "vor.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vor_b_vx{: vs1, vs2 : vd},
      disasm: "vor.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vor_b_vx_m{: vs1, vs2 : vd},
      disasm: "vor.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vor_h_vx{: vs1, vs2 : vd},
      disasm: "vor.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vor_h_vx_m{: vs1, vs2 : vd},
      disasm: "vor.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vor_w_vx{: vs1, vs2 : vd},
      disasm: "vor.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vor_w_vx_m{: vs1, vs2 : vd},
      disasm: "vor.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOr<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vxor
    vxor_vv{: vs1, vs2 : vd},
      disasm: "vxor.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vxor_vv_m{: vs1, vs2 : vd},
      disasm: "vxor.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vxor_b_vx{: vs1, vs2 : vd},
      disasm: "vxor.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vxor_b_vx_m{: vs1, vs2 : vd},
      disasm: "vxor.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vxor_h_vx{: vs1, vs2 : vd},
      disasm: "vxor.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vxor_h_vx_m{: vs1, vs2 : vd},
      disasm: "vxor.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vxor_w_vx{: vs1, vs2 : vd},
      disasm: "vxor.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vxor_w_vx_m{: vs1, vs2 : vd},
      disasm: "vxor.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVXor<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vrev
    vrev_b_vx{: vs1, vs2 : vd},
      disasm: "vrev.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint8_t>, /*strip_mine*/ false)";
    vrev_b_vx_m{: vs1, vs2 : vd},
      disasm: "vrev.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint8_t>, /*strip_mine*/ true)";
    vrev_h_vx{: vs1, vs2 : vd},
      disasm: "vrev.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint16_t>, /*strip_mine*/ false)";
    vrev_h_vx_m{: vs1, vs2 : vd},
      disasm: "vrev.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint16_t>, /*strip_mine*/ true)";
    vrev_w_vx{: vs1, vs2 : vd},
      disasm: "vrev.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint32_t>, /*strip_mine*/ false)";
    vrev_w_vx_m{: vs1, vs2 : vd},
      disasm: "vrev.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRev<uint32_t>, /*strip_mine*/ true)";

    //vror
    vror_b_vx{: vs1, vs2 : vd},
      disasm: "vror.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint8_t>, /*strip_mine*/ false)";
    vror_b_vx_m{: vs1, vs2 : vd},
      disasm: "vror.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint8_t>, /*strip_mine*/ true)";
    vror_h_vx{: vs1, vs2 : vd},
      disasm: "vror.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint16_t>, /*strip_mine*/ false)";
    vror_h_vx_m{: vs1, vs2 : vd},
      disasm: "vror.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint16_t>, /*strip_mine*/ true)";
    vror_w_vx{: vs1, vs2 : vd},
      disasm: "vror.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint32_t>, /*strip_mine*/ false)";
    vror_w_vx_m{: vs1, vs2 : vd},
      disasm: "vror.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVRor<uint32_t>, /*strip_mine*/ true)";

    //vmvp
    vmvp_vv{: vs1, vs2 : vd},
      disasm: "vmvp.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmvp_vv_m{: vs1, vs2 : vd},
      disasm: "vmvp.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmvp_b_vx{: vs1, vs2 : vd},
      disasm: "vmvp.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmvp_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmvp.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmvp_h_vx{: vs1, vs2 : vd},
      disasm: "vmvp.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmvp_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmvp.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmvp_w_vx{: vs1, vs2 : vd},
      disasm: "vmvp.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmvp_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmvp.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMvp<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsll
    vsll_b_vv{: vs1, vs2 : vd},
      disasm: "vsll.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsll_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsll.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsll_h_vv{: vs1, vs2 : vd},
      disasm: "vsll.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsll_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsll.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsll_w_vv{: vs1, vs2 : vd},
      disasm: "vsll.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsll_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsll.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsll_b_vx{: vs1, vs2 : vd},
      disasm: "vsll.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsll_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsll.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsll_h_vx{: vs1, vs2 : vd},
      disasm: "vsll.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsll_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsll.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsll_w_vx{: vs1, vs2 : vd},
      disasm: "vsll.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsll_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsll.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSll<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsra
    vsra_b_vv{: vs1, vs2 : vd},
      disasm: "vsra.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsra_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsra.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsra_h_vv{: vs1, vs2 : vd},
      disasm: "vsra.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsra_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsra.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsra_w_vv{: vs1, vs2 : vd},
      disasm: "vsra.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsra_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsra.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsra_b_vx{: vs1, vs2 : vd},
      disasm: "vsra.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsra_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsra.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsra_h_vx{: vs1, vs2 : vd},
      disasm: "vsra.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsra_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsra.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsra_w_vx{: vs1, vs2 : vd},
      disasm: "vsra.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsra_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsra.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSra<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsrl
    vsrl_b_vv{: vs1, vs2 : vd},
      disasm: "vsrl.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsrl_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsrl.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsrl_h_vv{: vs1, vs2 : vd},
      disasm: "vsrl.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsrl_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsrl.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsrl_w_vv{: vs1, vs2 : vd},
      disasm: "vsrl.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsrl_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsrl.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsrl_b_vx{: vs1, vs2 : vd},
      disasm: "vsrl.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsrl_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsrl.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsrl_h_vx{: vs1, vs2 : vd},
      disasm: "vsrl.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsrl_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsrl.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsrl_w_vx{: vs1, vs2 : vd},
      disasm: "vsrl.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsrl_w_vx_m{: vs1, vs2 : vd},
      disasm: "vsrl.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrl<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vsha
    vsha_b_vv{: vs1, vs2 : vd},
      disasm: "vsha.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int8_t>, /* round */ false, /*strip_mine*/ false)";
    vsha_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int8_t>, /* round */ false, /*strip_mine*/ true)";
    vsha_h_vv{: vs1, vs2 : vd},
      disasm: "vsha.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int16_t>, /* round */ false, /*strip_mine*/ false)";
    vsha_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int16_t>, /* round */ false, /*strip_mine*/ true)";
    vsha_w_vv{: vs1, vs2 : vd},
      disasm: "vsha.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int32_t>, /* round */ false, /*strip_mine*/ false)";
    vsha_w_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int32_t>, /* round */ false, /*strip_mine*/ true)";
    vsha_b_r_vv{: vs1, vs2 : vd},
      disasm: "vsha.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int8_t>, /* round */ true, /*strip_mine*/ false)";
    vsha_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int8_t>, /* round */ true, /*strip_mine*/ true)";
    vsha_h_r_vv{: vs1, vs2 : vd},
      disasm: "vsha.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int16_t>, /* round */ true, /*strip_mine*/ false)";
    vsha_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int16_t>, /* round */ true, /*strip_mine*/ true)";
    vsha_w_r_vv{: vs1, vs2 : vd},
      disasm: "vsha.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int32_t>, /* round */ true, /*strip_mine*/ false)";
    vsha_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsha.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<int32_t>, /* round */ true, /*strip_mine*/ true)";

    //vshl
    vshl_b_vv{: vs1, vs2 : vd},
      disasm: "vshl.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint8_t>, /* round */ false, /*strip_mine*/ false)";
    vshl_b_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint8_t>, /* round */ false, /*strip_mine*/ true)";
    vshl_h_vv{: vs1, vs2 : vd},
      disasm: "vshl.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint16_t>, /* round */ false, /*strip_mine*/ false)";
    vshl_h_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint16_t>, /* round */ false, /*strip_mine*/ true)";
    vshl_w_vv{: vs1, vs2 : vd},
      disasm: "vshl.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint32_t>, /* round */ false, /*strip_mine*/ false)";
    vshl_w_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint32_t>, /* round */ false, /*strip_mine*/ true)";
    vshl_b_r_vv{: vs1, vs2 : vd},
      disasm: "vshl.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint8_t>, /* round */ true, /*strip_mine*/ false)";
    vshl_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint8_t>, /* round */ true, /*strip_mine*/ true)";
    vshl_h_r_vv{: vs1, vs2 : vd},
      disasm: "vshl.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint16_t>, /* round */ true, /*strip_mine*/ false)";
    vshl_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint16_t>, /* round */ true, /*strip_mine*/ true)";
    vshl_w_r_vv{: vs1, vs2 : vd},
      disasm: "vshl.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint32_t>, /* round */ true, /*strip_mine*/ false)";
    vshl_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vshl.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVShift<uint32_t>, /* round */ true, /*strip_mine*/ true)";

    //vnot
    vnot_v{: vs1 : vd},
      disasm: "vnot.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVNot<int32_t>, /*strip_mine*/ false)";
    vnot_v_m{: vs1 : vd},
      disasm: "vnot.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVNot<int32_t>, /*strip_mine*/ true)";

    //vclb
    vclb_b_v{: vs1 : vd},
      disasm: "vclb.b.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint8_t>, /*strip_mine*/ false)";
    vclb_b_v_m{: vs1 : vd},
      disasm: "vclb.b.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint8_t>, /*strip_mine*/ true)";
    vclb_h_v{: vs1 : vd},
      disasm: "vclb.h.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint16_t>, /*strip_mine*/ false)";
    vclb_h_v_m{: vs1 : vd},
      disasm: "vclb.h.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint16_t>, /*strip_mine*/ true)";
    vclb_w_v{: vs1 : vd},
      disasm: "vclb.w.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint32_t>, /*strip_mine*/ false)";
    vclb_w_v_m{: vs1 : vd},
      disasm: "vclb.w.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClb<uint32_t>, /*strip_mine*/ true)";

    //vclz
    vclz_b_v{: vs1 : vd},
      disasm: "vclz.b.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint8_t>, /*strip_mine*/ false)";
    vclz_b_v_m{: vs1 : vd},
      disasm: "vclz.b.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint8_t>, /*strip_mine*/ true)";
    vclz_h_v{: vs1 : vd},
      disasm: "vclz.h.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint16_t>, /*strip_mine*/ false)";
    vclz_h_v_m{: vs1 : vd},
      disasm: "vclz.h.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint16_t>, /*strip_mine*/ true)";
    vclz_w_v{: vs1 : vd},
      disasm: "vclz.w.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint32_t>, /*strip_mine*/ false)";
    vclz_w_v_m{: vs1 : vd},
      disasm: "vclz.w.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVClz<uint32_t>, /*strip_mine*/ true)";

    //vcpop
    vcpop_b_v{: vs1 : vd},
      disasm: "vcpop.b.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint8_t>, /*strip_mine*/ false)";
    vcpop_b_v_m{: vs1 : vd},
      disasm: "vcpop.b.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint8_t>, /*strip_mine*/ true)";
    vcpop_h_v{: vs1 : vd},
      disasm: "vcpop.h.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint16_t>, /*strip_mine*/ false)";
    vcpop_h_v_m{: vs1 : vd},
      disasm: "vcpop.h.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint16_t>, /*strip_mine*/ true)";
    vcpop_w_v{: vs1 : vd},
      disasm: "vcpop.w.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint32_t>, /*strip_mine*/ false)";
    vcpop_w_v_m{: vs1 : vd},
      disasm: "vcpop.w.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVCpop<uint32_t>, /*strip_mine*/ true)";

    //vmv
    vmv_v{: vs1 : vd},
      disasm: "vmv.v", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVMv<int32_t>, /*strip_mine*/ false)";
    vmv_v_m{: vs1 : vd},
      disasm: "vmv.v.m", "%vd, %vs1",
      semfunc: "absl::bind_front(&KelvinVMv<int32_t>, /*strip_mine*/ true)";

    //vsrans
    vsrans_b_vv{: vs1, vs2 : vd},
      disasm: "vsrans.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsrans_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsrans.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsrans_h_vv{: vs1, vs2 : vd},
      disasm: "vsrans.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsrans_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsrans.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsrans_b_vx{: vs1, vs2 : vd},
      disasm: "vsrans.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsrans_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsrans.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsrans_h_vx{: vs1, vs2 : vd},
      disasm: "vsrans.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsrans_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsrans.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsrans_b_r_vv{: vs1, vs2 : vd},
      disasm: "vsrans.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsrans_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsrans.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsrans_h_r_vv{: vs1, vs2 : vd},
      disasm: "vsrans.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsrans_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsrans.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsrans_b_r_vx{: vs1, vs2 : vd},
      disasm: "vsrans.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsrans_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsrans.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int16_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";
    vsrans_h_r_vx{: vs1, vs2 : vd},
      disasm: "vsrans.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsrans_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsrans.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int16_t, int32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";

    //vsransu
    vsransu_b_vv{: vs1, vs2 : vd},
      disasm: "vsransu.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsransu_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsransu.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsransu_h_vv{: vs1, vs2 : vd},
      disasm: "vsransu.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsransu_h_vv_m{: vs1, vs2 : vd},
      disasm: "vsransu.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsransu_b_vx{: vs1, vs2 : vd},
      disasm: "vsransu.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsransu_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsransu.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsransu_h_vx{: vs1, vs2 : vd},
      disasm: "vsransu.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsransu_h_vx_m{: vs1, vs2 : vd},
      disasm: "vsransu.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsransu_b_r_vv{: vs1, vs2 : vd},
      disasm: "vsransu.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsransu_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsransu.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsransu_h_r_vv{: vs1, vs2 : vd},
      disasm: "vsransu.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsransu_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsransu.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsransu_b_r_vx{: vs1, vs2 : vd},
      disasm: "vsransu.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsransu_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsransu.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint16_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";
    vsransu_h_r_vx{: vs1, vs2 : vd},
      disasm: "vsransu.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsransu_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsransu.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint16_t, uint32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";

    //vsraqs
    vsraqs_b_vv{: vs1, vs2 : vd},
      disasm: "vsraqs.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsraqs_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsraqs.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsraqs_b_vx{: vs1, vs2 : vd},
      disasm: "vsraqs.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsraqs_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsraqs.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsraqs_b_r_vv{: vs1, vs2 : vd},
      disasm: "vsraqs.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsraqs_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsraqs.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsraqs_b_r_vx{: vs1, vs2 : vd},
      disasm: "vsraqs.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsraqs_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsraqs.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<int8_t, int32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";

    //vsraqsu
    vsraqsu_b_vv{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ false)";
    vsraqsu_b_vv_m{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ false, /*scalar*/ false, /*strip_mine*/ true)";
    vsraqsu_b_vx{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ false)";
    vsraqsu_b_vx_m{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ false, /*scalar*/ true, /*strip_mine*/ true)";
    vsraqsu_b_r_vv{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ false)";
    vsraqsu_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ true, /*scalar*/ false, /*strip_mine*/ true)";
    vsraqsu_b_r_vx{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ false)";
    vsraqsu_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vsraqsu.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSrans<uint8_t, uint32_t>, /*round*/ true, /*scalar*/ true, /*strip_mine*/ true)";

    //vmul
    vmul_b_vv{: vs1, vs2 : vd},
      disasm: "vmul.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmul_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmul.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmul_h_vv{: vs1, vs2 : vd},
      disasm: "vmul.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmul_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmul.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmul_w_vv{: vs1, vs2 : vd},
      disasm: "vmul.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmul_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmul.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmul_b_vx{: vs1, vs2 : vd},
      disasm: "vmul.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmul_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmul.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmul_h_vx{: vs1, vs2 : vd},
      disasm: "vmul.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmul_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmul.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmul_w_vx{: vs1, vs2 : vd},
      disasm: "vmul.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmul_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmul.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMul<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

   //vmuls
    vmuls_b_vv{: vs1, vs2 : vd},
      disasm: "vmuls.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmuls_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmuls.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmuls_h_vv{: vs1, vs2 : vd},
      disasm: "vmuls.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmuls_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmuls.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmuls_w_vv{: vs1, vs2 : vd},
      disasm: "vmuls.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmuls_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmuls.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmuls_b_vx{: vs1, vs2 : vd},
      disasm: "vmuls.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmuls_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmuls.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmuls_h_vx{: vs1, vs2 : vd},
      disasm: "vmuls.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmuls_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmuls.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmuls_w_vx{: vs1, vs2 : vd},
      disasm: "vmuls.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmuls_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmuls.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vmulsu
    vmulsu_b_vv{: vs1, vs2 : vd},
      disasm: "vmulsu.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulsu_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmulsu.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulsu_h_vv{: vs1, vs2 : vd},
      disasm: "vmulsu.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulsu_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmulsu.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulsu_w_vv{: vs1, vs2 : vd},
      disasm: "vmulsu.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulsu_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmulsu.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulsu_b_vx{: vs1, vs2 : vd},
      disasm: "vmulsu.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulsu_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmulsu.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmulsu_h_vx{: vs1, vs2 : vd},
      disasm: "vmulsu.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulsu_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmulsu.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmulsu_w_vx{: vs1, vs2 : vd},
      disasm: "vmulsu.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulsu_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmulsu.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMuls<uint32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vmulw
    vmulw_h_vv{: vs1, vs2 : vd},
      disasm: "vmulw.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulw_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmulw.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int16_t, int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulw_w_vv{: vs1, vs2 : vd},
      disasm: "vmulw.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulw_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmulw.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int32_t, int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulw_h_vx{: vs1, vs2 : vd},
      disasm: "vmulw.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulw_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmulw.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int16_t, int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmulw_w_vx{: vs1, vs2 : vd},
      disasm: "vmulw.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulw_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmulw.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<int32_t, int16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vmulwu
    vmulw_h_u_vv{: vs1, vs2 : vd},
      disasm: "vmulw.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulw_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vmulw.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint16_t, uint8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulw_w_u_vv{: vs1, vs2 : vd},
      disasm: "vmulw.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmulw_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vmulw.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint32_t, uint16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmulw_h_u_vx{: vs1, vs2 : vd},
      disasm: "vmulw.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulw_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vmulw.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint16_t, uint8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmulw_w_u_vx{: vs1, vs2 : vd},
      disasm: "vmulw.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmulw_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vmulw.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulw<uint32_t, uint16_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vmulh
    vmulh_b_vv{: vs1, vs2 : vd},
      disasm: "vmulh.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_h_vv{: vs1, vs2 : vd},
      disasm: "vmulh.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_w_vv{: vs1, vs2 : vd},
      disasm: "vmulh.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_b_vx{: vs1, vs2 : vd},
      disasm: "vmulh.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vmulh_h_vx{: vs1, vs2 : vd},
      disasm: "vmulh.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vmulh_w_vx{: vs1, vs2 : vd},
      disasm: "vmulh.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vmulh.r
    vmulh_b_r_vv{: vs1, vs2 : vd},
      disasm: "vmulh.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_h_r_vv{: vs1, vs2 : vd},
      disasm: "vmulh.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_w_r_vv{: vs1, vs2 : vd},
      disasm: "vmulh.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_b_r_vx{: vs1, vs2 : vd},
      disasm: "vmulh.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vmulh_h_r_vx{: vs1, vs2 : vd},
      disasm: "vmulh.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vmulh_w_r_vx{: vs1, vs2 : vd},
      disasm: "vmulh.w.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_w_r_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vmulh.u
    vmulh_b_u_vv{: vs1, vs2 : vd},
      disasm: "vmulh.b.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_b_u_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_h_u_vv{: vs1, vs2 : vd},
      disasm: "vmulh.h.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_h_u_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_w_u_vv{: vs1, vs2 : vd},
      disasm: "vmulh.w.u.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false)";
    vmulh_w_u_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.u.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false)";
    vmulh_b_u_vx{: vs1, vs2 : vd},
      disasm: "vmulh.b.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_b_u_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vmulh_h_u_vx{: vs1, vs2 : vd},
      disasm: "vmulh.h.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_h_u_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";
    vmulh_w_u_vx{: vs1, vs2 : vd},
      disasm: "vmulh.w.u.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false)";
    vmulh_w_u_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.u.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false)";

    //vmulh.ru
    vmulh_b_ur_vv{: vs1, vs2 : vd},
      disasm: "vmulh.b.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_b_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_h_ur_vv{: vs1, vs2 : vd},
      disasm: "vmulh.h.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_h_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_w_ur_vv{: vs1, vs2 : vd},
      disasm: "vmulh.w.ur.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true)";
    vmulh_w_ur_vv_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.ur.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true)";
    vmulh_b_ur_vx{: vs1, vs2 : vd},
      disasm: "vmulh.b.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_b_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.b.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vmulh_h_ur_vx{: vs1, vs2 : vd},
      disasm: "vmulh.h.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_h_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.h.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";
    vmulh_w_ur_vx{: vs1, vs2 : vd},
      disasm: "vmulh.w.ur.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true)";
    vmulh_w_ur_vx_m{: vs1, vs2 : vd},
      disasm: "vmulh.w.ur.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMulh<uint32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true)";

    //vdmulh
    vdmulh_b_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_b_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";
    vdmulh_h_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_h_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";
    vdmulh_w_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_w_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";
    vdmulh_b_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_b_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";
    vdmulh_h_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_h_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";
    vdmulh_w_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ false, /* round_neg */ false)";
    vdmulh_w_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ false, /* round_neg */ false)";

    //vdmulh.r
    vdmulh_b_r_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.b.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_b_r_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";
    vdmulh_h_r_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.h.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_h_r_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";
    vdmulh_w_r_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.w.r.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_w_r_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.r.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";
    vdmulh_b_r_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.b.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_b_r_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";
    vdmulh_h_r_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.h.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_h_r_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";
    vdmulh_w_r_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.w.r.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ false)";
    vdmulh_w_r_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.r.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ false)";

    //vdmulh.rn
    vdmulh_b_rn_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.b.rn.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_b_rn_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.rn.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";
    vdmulh_h_rn_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.h.rn.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_h_rn_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.rn.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";
    vdmulh_w_rn_vv{: vs1, vs2 : vd},
      disasm: "vdmulh.w.rn.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_w_rn_vv_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.rn.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ false, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";
    vdmulh_b_rn_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.b.rn.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_b_rn_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.b.rn.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int8_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";
    vdmulh_h_rn_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.h.rn.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_h_rn_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.h.rn.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int16_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";
    vdmulh_w_rn_vx{: vs1, vs2 : vd},
      disasm: "vdmulh.w.rn.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ false, /* round */ true, /* round_neg */ true)";
    vdmulh_w_rn_vx_m{: vs1, vs2 : vd},
      disasm: "vdmulh.w.rn.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVDmulh<int32_t>, /*scalar*/ true, /*strip_mine*/ true, /* round */ true, /* round_neg */ true)";

    //vmacc
    vmacc_b_vv{: vs1, vs2 : vd},
      disasm: "vmacc.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmacc_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmacc.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmacc_h_vv{: vs1, vs2 : vd},
      disasm: "vmacc.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmacc_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmacc.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmacc_w_vv{: vs1, vs2 : vd},
      disasm: "vmacc.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmacc_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmacc.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmacc_b_vx{: vs1, vs2 : vd},
      disasm: "vmacc.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmacc_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmacc.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmacc_h_vx{: vs1, vs2 : vd},
      disasm: "vmacc.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmacc_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmacc.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmacc_w_vx{: vs1, vs2 : vd},
      disasm: "vmacc.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmacc_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmacc.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMacc<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vmadd
    vmadd_b_vv{: vs1, vs2 : vd},
      disasm: "vmadd.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmadd_b_vv_m{: vs1, vs2 : vd},
      disasm: "vmadd.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmadd_h_vv{: vs1, vs2 : vd},
      disasm: "vmadd.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmadd_h_vv_m{: vs1, vs2 : vd},
      disasm: "vmadd.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmadd_w_vv{: vs1, vs2 : vd},
      disasm: "vmadd.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vmadd_w_vv_m{: vs1, vs2 : vd},
      disasm: "vmadd.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vmadd_b_vx{: vs1, vs2 : vd},
      disasm: "vmadd.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmadd_b_vx_m{: vs1, vs2 : vd},
      disasm: "vmadd.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmadd_h_vx{: vs1, vs2 : vd},
      disasm: "vmadd.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmadd_h_vx_m{: vs1, vs2 : vd},
      disasm: "vmadd.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vmadd_w_vx{: vs1, vs2 : vd},
      disasm: "vmadd.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vmadd_w_vx_m{: vs1, vs2 : vd},
      disasm: "vmadd.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVMadd<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vslidevn
    vslidevn_b_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.b.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int8_t>, 1 /* index */)";
    vslidevn_b_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.b.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int8_t>, 2 /* index */)";
    vslidevn_b_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.b.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int8_t>, 3 /* index */)";
    vslidevn_b_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.b.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int8_t>, 4 /* index */)";
    vslidevn_h_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.h.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int16_t>, 1 /* index */)";
    vslidevn_h_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.h.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int16_t>, 2 /* index */)";
    vslidevn_h_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.h.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int16_t>, 3 /* index */)";
    vslidevn_h_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.h.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int16_t>, 4 /* index */)";
    vslidevn_w_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.w.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int32_t>, 1 /* index */)";
    vslidevn_w_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.w.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int32_t>, 2 /* index */)";
    vslidevn_w_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.w.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int32_t>, 3 /* index */)";
    vslidevn_w_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevn.w.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevn<int32_t>, 4 /* index */)";

    //vslidehn
    vslidehn_b_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.b.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int8_t>, 1 /* index */)";
    vslidehn_b_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.b.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int8_t>, 2 /* index */)";
    vslidehn_b_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.b.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int8_t>, 3 /* index */)";
    vslidehn_b_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.b.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int8_t>, 4 /* index */)";
    vslidehn_h_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.h.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int16_t>, 1 /* index */)";
    vslidehn_h_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.h.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int16_t>, 2 /* index */)";
    vslidehn_h_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.h.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int16_t>, 3 /* index */)";
    vslidehn_h_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.h.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int16_t>, 4 /* index */)";
    vslidehn_w_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.w.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int32_t>, 1 /* index */)";
    vslidehn_w_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.w.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int32_t>, 2 /* index */)";
    vslidehn_w_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.w.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int32_t>, 3 /* index */)";
    vslidehn_w_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehn.w.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehn<int32_t>, 4 /* index */)";

    //vslidevp
    vslidevp_b_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.b.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int8_t>, 1 /* index */)";
    vslidevp_b_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.b.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int8_t>, 2 /* index */)";
    vslidevp_b_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.b.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int8_t>, 3 /* index */)";
    vslidevp_b_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.b.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int8_t>, 4 /* index */)";
    vslidevp_h_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.h.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int16_t>, 1 /* index */)";
    vslidevp_h_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.h.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int16_t>, 2 /* index */)";
    vslidevp_h_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.h.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int16_t>, 3 /* index */)";
    vslidevp_h_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.h.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int16_t>, 4 /* index */)";
    vslidevp_w_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.w.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int32_t>, 1 /* index */)";
    vslidevp_w_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.w.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int32_t>, 2 /* index */)";
    vslidevp_w_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.w.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int32_t>, 3 /* index */)";
    vslidevp_w_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidevp.w.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidevp<int32_t>, 4 /* index */)";

    //vslidehp
    vslidehp_b_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.b.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int8_t>, 1 /* index */)";
    vslidehp_b_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.b.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int8_t>, 2 /* index */)";
    vslidehp_b_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.b.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int8_t>, 3 /* index */)";
    vslidehp_b_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.b.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int8_t>, 4 /* index */)";
    vslidehp_h_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.h.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int16_t>, 1 /* index */)";
    vslidehp_h_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.h.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int16_t>, 2 /* index */)";
    vslidehp_h_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.h.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int16_t>, 3 /* index */)";
    vslidehp_h_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.h.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int16_t>, 4 /* index */)";
    vslidehp_w_1_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.w.1.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int32_t>, 1 /* index */)";
    vslidehp_w_2_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.w.2.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int32_t>, 2 /* index */)";
    vslidehp_w_3_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.w.3.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int32_t>, 3 /* index */)";
    vslidehp_w_4_vv_m{: vs1, vs2 : vd},
      disasm: "vslidehp.w.4.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSlidehp<int32_t>, 4 /* index */)";

    //vsel
    vsel_b_vv{: vs1, vs2, vd : vd},
      disasm: "vsel.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsel_b_vv_m{: vs1, vs2, vd : vd},
      disasm: "vsel.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsel_h_vv{: vs1, vs2, vd : vd},
      disasm: "vsel.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsel_h_vv_m{: vs1, vs2, vd : vd},
      disasm: "vsel.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsel_w_vv{: vs1, vs2, vd : vd},
      disasm: "vsel.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vsel_w_vv_m{: vs1, vs2, vd : vd},
      disasm: "vsel.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vsel_b_vx{: vs1, vs2, vd : vd},
      disasm: "vsel.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsel_b_vx_m{: vs1, vs2, vd : vd},
      disasm: "vsel.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsel_h_vx{: vs1, vs2, vd : vd},
      disasm: "vsel.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsel_h_vx_m{: vs1, vs2, vd : vd},
      disasm: "vsel.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vsel_w_vx{: vs1, vs2, vd : vd},
      disasm: "vsel.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vsel_w_vx_m{: vs1, vs2, vd : vd},
      disasm: "vsel.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVSel<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vevn
    vevn_b_vv{: vs1, vs2 : vd},
      disasm: "vevn.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevn_b_vv_m{: vs1, vs2 : vd},
      disasm: "vevn.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevn_h_vv{: vs1, vs2 : vd},
      disasm: "vevn.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevn_h_vv_m{: vs1, vs2 : vd},
      disasm: "vevn.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevn_w_vv{: vs1, vs2 : vd},
      disasm: "vevn.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevn_w_vv_m{: vs1, vs2 : vd},
      disasm: "vevn.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevn_b_vx{: vs1, vs2 : vd},
      disasm: "vevn.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevn_b_vx_m{: vs1, vs2 : vd},
      disasm: "vevn.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vevn_h_vx{: vs1, vs2 : vd},
      disasm: "vevn.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevn_h_vx_m{: vs1, vs2 : vd},
      disasm: "vevn.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vevn_w_vx{: vs1, vs2 : vd},
      disasm: "vevn.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevn_w_vx_m{: vs1, vs2 : vd},
      disasm: "vevn.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvn<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vodd
    vodd_b_vv{: vs1, vs2 : vd},
      disasm: "vodd.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vodd_b_vv_m{: vs1, vs2 : vd},
      disasm: "vodd.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vodd_h_vv{: vs1, vs2 : vd},
      disasm: "vodd.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vodd_h_vv_m{: vs1, vs2 : vd},
      disasm: "vodd.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vodd_w_vv{: vs1, vs2 : vd},
      disasm: "vodd.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vodd_w_vv_m{: vs1, vs2 : vd},
      disasm: "vodd.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vodd_b_vx{: vs1, vs2 : vd},
      disasm: "vodd.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vodd_b_vx_m{: vs1, vs2 : vd},
      disasm: "vodd.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vodd_h_vx{: vs1, vs2 : vd},
      disasm: "vodd.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vodd_h_vx_m{: vs1, vs2 : vd},
      disasm: "vodd.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vodd_w_vx{: vs1, vs2 : vd},
      disasm: "vodd.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vodd_w_vx_m{: vs1, vs2 : vd},
      disasm: "vodd.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVOdd<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vevnodd
    vevnodd_b_vv{: vs1, vs2 : vd},
      disasm: "vevnodd.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevnodd_b_vv_m{: vs1, vs2 : vd},
      disasm: "vevnodd.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevnodd_h_vv{: vs1, vs2 : vd},
      disasm: "vevnodd.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevnodd_h_vv_m{: vs1, vs2 : vd},
      disasm: "vevnodd.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevnodd_w_vv{: vs1, vs2 : vd},
      disasm: "vevnodd.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vevnodd_w_vv_m{: vs1, vs2 : vd},
      disasm: "vevnodd.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vevnodd_b_vx{: vs1, vs2 : vd},
      disasm: "vevnodd.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevnodd_b_vx_m{: vs1, vs2 : vd},
      disasm: "vevnodd.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vevnodd_h_vx{: vs1, vs2 : vd},
      disasm: "vevnodd.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevnodd_h_vx_m{: vs1, vs2 : vd},
      disasm: "vevnodd.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vevnodd_w_vx{: vs1, vs2 : vd},
      disasm: "vevnodd.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vevnodd_w_vx_m{: vs1, vs2 : vd},
      disasm: "vevnodd.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVEvnodd<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vzip
    vzip_b_vv{: vs1, vs2 : vd},
      disasm: "vzip.b.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int8_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vzip_b_vv_m{: vs1, vs2 : vd},
      disasm: "vzip.b.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int8_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vzip_h_vv{: vs1, vs2 : vd},
      disasm: "vzip.h.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int16_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vzip_h_vv_m{: vs1, vs2 : vd},
      disasm: "vzip.h.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int16_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vzip_w_vv{: vs1, vs2 : vd},
      disasm: "vzip.w.vv", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int32_t>, /*scalar*/ false, /*strip_mine*/ false)";
    vzip_w_vv_m{: vs1, vs2 : vd},
      disasm: "vzip.w.vv.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int32_t>, /*scalar*/ false, /*strip_mine*/ true)";
    vzip_b_vx{: vs1, vs2 : vd},
      disasm: "vzip.b.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int8_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vzip_b_vx_m{: vs1, vs2 : vd},
      disasm: "vzip.b.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int8_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vzip_h_vx{: vs1, vs2 : vd},
      disasm: "vzip.h.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int16_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vzip_h_vx_m{: vs1, vs2 : vd},
      disasm: "vzip.h.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int16_t>, /*scalar*/ true, /*strip_mine*/ true)";
    vzip_w_vx{: vs1, vs2 : vd},
      disasm: "vzip.w.vx", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int32_t>, /*scalar*/ true, /*strip_mine*/ false)";
    vzip_w_vx_m{: vs1, vs2 : vd},
      disasm: "vzip.w.vx.m", "%vd, %vs1, %vs2",
      semfunc: "absl::bind_front(&KelvinVZip<int32_t>, /*scalar*/ true, /*strip_mine*/ true)";

    //vld
    vld_b_x{(: vs1 :), (: : vd)},
    disasm: "vld.b.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>, /*strip_mine*/ false)";
    vld_h_x{(: vs1 :), (: : vd)},
    disasm: "vld.h.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_x{(: vs1 :), (: : vd)},
    disasm: "vld.w.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_x_m{(: vs1 :), (: : vd)},
    disasm: "vld.b.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_x_m{(: vs1 :), (: : vd)},
    disasm: "vld.h.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_x_m{(: vs1 :), (: : vd)},
    disasm: "vld.w.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_p_x{(: vs1 : vs1), (: : vd)},
    disasm: "vld.b.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ false)";
    vld_h_p_x{(: vs1 : vs1), (: : vd)},
    disasm: "vld.h.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_p_x{(: vs1 : vs1), (: : vd)},
    disasm: "vld.w.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_p_x_m{(: vs1 : vs1), (: : vd)},
    disasm: "vld.b.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_p_x_m{(: vs1 : vs1), (: : vd)},
    disasm: "vld.h.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_p_x_m{(: vs1 : vs1), (: : vd)},
    disasm: "vld.w.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_p_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ false)";
    vld_h_p_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_p_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_p_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_p_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_p_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_l_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.b.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>, /*strip_mine*/ false)";
    vld_h_l_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.h.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_l_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.w.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_l_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.b.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_l_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.h.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_l_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.w.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_lp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ false)";
    vld_h_lp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_lp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_lp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_lp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_lp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_s_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.b.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>, /*strip_mine*/ false)";
    vld_h_s_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.h.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_s_xx{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.w.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_s_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.b.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_s_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.h.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_s_xx_m{(: vs1, vs2 :), (: : vd)},
    disasm: "vld.w.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_sp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ false)";
    vld_h_sp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_sp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_sp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_sp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_sp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    vld_b_tp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ false)";
    vld_h_tp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ false)";
    vld_w_tp_xx{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ false)";
    vld_b_tp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.b.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int8_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int8_t>,/*strip_mine*/ true)";
    vld_h_tp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.h.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int16_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int16_t>,/*strip_mine*/ true)";
    vld_w_tp_xx_m{(: vs1, vs2 : vs1), (: : vd)},
    disasm: "vld.w.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVLd<int32_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)",
             "absl::bind_front(&KelvinVLdRegWrite<int32_t>,/*strip_mine*/ true)";
    //vst, note `vd` is actually the source vector register, and `vs1` is actually the scaler register.
    vst_b_x{: vd, vs1 :},
    disasm: "vst.b.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_h_x{: vd, vs1 :},
    disasm: "vst.h.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_w_x{: vd, vs1 :},
    disasm: "vst.w.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_b_x_m{: vd, vs1 :},
    disasm: "vst.b.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_h_x_m{: vd, vs1 :},
    disasm: "vst.h.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_w_x_m{: vd, vs1 :},
    disasm: "vst.w.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_b_p_x{: vd, vs1 : vs1},
    disasm: "vst.b.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_h_p_x{: vd, vs1 : vs1},
    disasm: "vst.h.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_w_p_x{: vd, vs1 : vs1},
    disasm: "vst.w.p.x", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_b_p_x_m{: vd, vs1 : vs1},
    disasm: "vst.b.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_h_p_x_m{: vd, vs1 : vs1},
    disasm: "vst.h.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_w_p_x_m{: vd, vs1 : vs1},
    disasm: "vst.w.p.x.m", "%vd, %vs1",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_b_p_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_h_p_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_w_p_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.p.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ false)";
    vst_b_p_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_h_p_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_w_p_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vld.w.p.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ false, /*strip_mine*/ true)";
    vst_b_l_xx{: vd, vs1, vs2 :},
    disasm: "vst.b.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_h_l_xx{: vd, vs1, vs2 :},
    disasm: "vst.h.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_w_l_xx{: vd, vs1, vs2 :},
    disasm: "vst.w.l.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_b_l_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.b.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_h_l_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.h.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_w_l_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.w.l.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_b_lp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_h_lp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_w_lp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.lp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ false)";
    vst_b_lp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_h_lp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_w_lp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.lp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ false, /*strip_mine*/ true)";
    vst_b_s_xx{: vd, vs1, vs2 :},
    disasm: "vst.b.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_h_s_xx{: vd, vs1, vs2 :},
    disasm: "vst.h.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_w_s_xx{: vd, vs1, vs2 :},
    disasm: "vst.w.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_b_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.b.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_h_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.h.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_w_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vst.w.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_b_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_h_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_w_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.sp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ false)";
    vst_b_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_h_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_w_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.sp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ false, /*stride*/ true, /*strip_mine*/ true)";
    vst_b_tp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)";
    vst_h_tp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)";
    vst_w_tp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.tp.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ false)";
    vst_b_tp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.b.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int8_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)";
    vst_h_tp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.h.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int16_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)";
    vst_w_tp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vst.w.tp.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVSt<int32_t>, /*len*/ true, /*stride*/ true, /*strip_mine*/ true)";
    vstq_b_s_xx{: vd, vs1, vs2 :},
    disasm: "vstq.b.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int8_t>, /*strip_mine*/ false)";
    vstq_h_s_xx{: vd, vs1, vs2 :},
    disasm: "vstq.h.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int16_t>, /*strip_mine*/ false)";
    vstq_w_s_xx{: vd, vs1, vs2 :},
    disasm: "vstq.w.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int32_t>, /*strip_mine*/ false)";
    vstq_b_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vstq.b.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int8_t>, /*strip_mine*/ false)";
    vstq_h_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vstq.h.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int16_t>, /*strip_mine*/ false)";
    vstq_w_sp_xx{: vd, vs1, vs2 : vs1},
    disasm: "vstq.w.s.xx", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int32_t>, /*strip_mine*/ false)";
    vstq_b_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vstq.b.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int8_t>, /*strip_mine*/ true)";
    vstq_h_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vstq.h.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int16_t>, /*strip_mine*/ true)";
    vstq_w_s_xx_m{: vd, vs1, vs2 :},
    disasm: "vstq.w.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int32_t>, /*strip_mine*/ true)";
    vstq_b_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vstq.b.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int8_t>, /*strip_mine*/ true)";
    vstq_h_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vstq.h.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int16_t>, /*strip_mine*/ true)";
    vstq_w_sp_xx_m{: vd, vs1, vs2 : vs1},
    disasm: "vstq.w.s.xx.m", "%vd, %vs1, %vs2",
    semfunc: "absl::bind_front(&KelvinVStQ<int32_t>, /*strip_mine*/ true)";
  }
}

slot kelvin_memory {
  includes {
    #include "sim/kelvin_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    flushall{},
      disasm: "flushall",
      semfunc: "&KelvinNopInstruction";
    flushat{: rs1 :},
      disasm: "flushat", "%rs1",
      semfunc: "&KelvinNopInstruction";
  }
}

slot kelvin_system {
  includes {
    #include "sim/kelvin_vector_memory_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  resources TwoOp = { next_pc, rs1 : rd[..rd]};
  resources ThreeOp = { next_pc, rs1, rs2 : rd[..rd]};
  opcodes {
    getmaxvl_b{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.b", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ false, /*is_rs1*/ false, /*is_rs2*/ false)";
    getmaxvl_h{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.h", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ false, /*is_rs1*/ false, /*is_rs2*/ false)";
    getmaxvl_w{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.w", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ false, /*is_rs1*/ false, /*is_rs2*/ false)";
    getvl_b_x{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.b.x", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_h_x{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.h.x", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_w_x{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.w.x", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_b_xx{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.b.xx", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ true)";
    getvl_h_xx{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.h.xx", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ true)";
    getvl_w_xx{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.w.xx", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ false, /*is_rs1*/ true, /*is_rs2*/ true)";
    getmaxvl_b_m{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.b.m", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ true, /*is_rs1*/ false, /*is_rs2*/ false)";
    getmaxvl_h_m{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.h.m", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ true, /*is_rs1*/ false, /*is_rs2*/ false)";
    getmaxvl_w_m{: : rd},
      resources: { next_pc : rd[0..]},
      disasm: "getmaxvl.w.m", "%rd",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ true, /*is_rs1*/ false, /*is_rs2*/ false)";
    getvl_b_x_m{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.b.x.m", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_h_x_m{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.h.x.m", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_w_x_m{: rs1 : rd},
      resources: TwoOp,
      disasm: "getvl.w.x.m", "%rd, %rs1",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ false)";
    getvl_b_xx_m{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.b.xx.m", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int8_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ true)";
    getvl_h_xx_m{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.h.xx.m", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int16_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ true)";
    getvl_w_xx_m{: rs1, rs2 : rd},
      resources: ThreeOp,
      disasm: "getvl.w.xx.m", "%rd, %rs1, %rs2",
      semfunc: "absl::bind_front(&KelvinGetVl<int32_t>, /*strip_mine*/ true, /*is_rs1*/ true, /*is_rs2*/ true)";
  }
}

slot kelvin_log {
  includes {
    #include "sim/kelvin_instructions.h"
  }
  default size = 4;
  default latency = global_latency;
  opcodes {
    flog{: rs1 :},
      resources: { next_pc : rs1[0..]},
      disasm: "flog", "%rs1",
      semfunc: "absl::bind_front(&KelvinLogInstruction, /*log_mode*/ 0)";
    slog{: rs1 :},
      resources: { next_pc : rs1[0..]},
      disasm: "slog", "%rs1",
      semfunc: "absl::bind_front(&KelvinLogInstruction, /*log_mode*/ 1)";
    clog{: rs1 :},
      resources: { next_pc : rs1[0..]},
      disasm: "clog", "%rs1",
      semfunc: "absl::bind_front(&KelvinLogInstruction, /*log_mode*/ 2)";
    klog{: rs1 :},
      resources: { next_pc : rs1[0..]},
      disasm: "klog", "%rs1",
      semfunc: "absl::bind_front(&KelvinLogInstruction, /*log_mode*/ 3)";
  }
}

// Combining all kelvin instruction sets.
slot kelvin : riscv32i, riscv32m, zicsr, zfencei, privileged, kelvin_arith, kelvin_log, kelvin_memory, kelvin_system {
  includes {
    #include "sim/kelvin_instructions.h"
  }
  default opcode =
    disasm: "Illegal instruction at 0x%(@:08x)",
    semfunc: "&KelvinIllegalInstruction";
}
